# C语言知识 {ignore=true}

[TOC]

## 1.计算机基础

### 1. 系统位数

位数分别为16、32、64最基本原理是从硬件来讲的。 从CPU的发展史来看，从以前的8位到现在的64位，8位也就是CPU在一个时钟周期内可并行处理8位二进字符0或是1，那么16就以此类推是16位二进制.32位就是32位二进制。64位就64位二进制。因为电脑是软硬相配合才能发挥最佳性能的。所以操作系统也必须从32位的到64位的，这样才能发挥出最佳的性能。

### 2. 编译错误和语法错误

- 任何一种语言都可以实现编译器的功能，只不过效率有高低之分，汇编的效率最高。

### 3. 存储方式

计算机当中存储数据的补码形式，便于加减法运算。

## 2. 关键字和运算符

### 1.   static

- c语言中，static用来说明静态变量。
- 如果是在函数外面定义的，那么其效果和全局变量类似，即static说明的变量可以在当前c程序文件中使用。
- 如果是在函数内部定义的，那么这个变量只初始化一次，即使再次调用这个函数，这个static变量也不会再次被初始化，于是，这个变量的取值就会一直保存着，我们再次调用该函数时，仍是保存的上一次函数调用时保存的结果。

举例说明

```C
static int a;
int b;
void func(void)
{
    static int c;
    int d;
}
```

上面程序中，a与b都是全局变量，二者的区别是，b可以被别的文件使用，a只能在本文件中使用，这是static对全局变量的作用。
c和d的区别是，d是一个自动变量，func函数执行完后，d会自动被释放。但c却不会被释放，下一次调用func函数时，c的值会保留上次的值继续使用。

### 2. new

- C++中可以使用new在运行阶段分配内存
- 动态分配内存的格式：

``` C++
int * pn = new int; 
typeName * point_name = new typeName;
```

- new运算符返回该内存的地址
- 数据对象指的是为数据项分配的内存块。
- 动态分配内存使程序在管理内存方面有更大的控制权。
- new分配的内存块通常与常规变量声明分配的内存块不同。变量的值都存储在栈内存(stack)区域中;而new运算符从堆 (heap)或自由存储区 (free store)的内存区域分配内存。
  
### 3. delete

- delete 运算符可以在使用完内存后，将内存归还给内存池。归还或释放的内存可供程序的其他部分使用。
- 使用delete 时，后面要加上指向内存块的指针变量(内存块是由new分配)∶

```C++
  int * ps = new int;
delete ps;
```

注意:
>
> - 一定要配对地使用new和 delete，否则会发生内存泄漏(memory leak) ;
> - 不要释放已经释放的内存块;
> - 不能使用delete 来释放声明变量所获得的内存;
> - delete释放的是内存，不会删除变量本身，变量仍可获得另一个新分配的内存块

### 4. sizeof

- 对数组名进行 sizeof，获取的是数组的字节大小，sizeof(testArray[0]) 是获取第一个元素的字节大小。
- 通过函数调用后，数组名退化为指针，此时sizeof(数组名)获取的是指针的字节大小

## 3. 运算符

### 1. 运算符的优先级和结合性

![运算符表格](images/4289c14511d4c7de0b692cb11bc2b13c.jpg)

1. 结合方向只有三个是从右往左，其余都是从左往右。
2. 所有双目运算符中只有赋值运算符的结合方向是从右往左。
3. 另外两个从右往左结合的运算符也很好记，因为它们很特殊：一个是单目运算符，一个是三目运算符。
4. C语言中有且只有一个三目运算符。
5. 逗号运算符的优先级最低，要记住。
6. 此外要记住，对于优先级：算术运算符 > 关系运算符 > 逻辑运算符 > 赋值运算符。逻辑运算符中“逻辑非 !”除外。
7. 在复杂等式中要注意短路效应

### 2. printf函数常用格式字符串和附加格式字符

#### 1. 格式字符串

| 类型   | 格式字符串 | 输出形式                                               |
|--------|------------|--------------------------------------------------------|
| 整型   | %d         | 带符号的十进制形式（正数不输出符号+）                  |
| 整型   | %o         | 无符号的八进制形式（不输出前导符号0）                  |
| 整型   | %x或%X     | 无符号的十六进制形式（不输出前导符号0x或0X             |
| 整型   | %u         | 无符号的十进制形式                                     |
| 实型   | %f         | 小数形式，默认小数位数为6位                            |
| 实型   | %e或%E     | 指数形式，数字部分默认为6位                            |
| 实型   | %g或%G     | 优化的小数或指数形式（去掉无意义的0后所占宽度较少的1种 |
| 字符型 | %c         | 单个字符形式（不输出单引号’）                         |
| 字符型 | %s         | 字符串（不输出双引号”）                               |

#### 2. 常用附加格式字符

| 字符 | 功能                                                   | 示例     |
|------|--------------------------------------------------------|----------|
| m    | 输出数据域宽，当数据长度< m时，左补空格，否则按实际输出 | %8d      |
| n    | 对实数，指定小数点后位数（四舍五入）                   | %.3f     |
| n    | 对字符串，指定实际输出位数                             | %.6s     |
| -    | 输出数据在域内时左对齐（缺省时右对齐）                 | %-8d     |
| +    | 指定在有符号数的正数前显示正号（+）                    | %+8d     |
| 0    | 输出数值时指定左面不使用的空位置自动填0                | %08d     |
| #    | 在八进制和十六进制前显示前导0，0x                      | %#o和%#x |
| l    | 在d,o,x,u前，指定输出精度为long型                      | %ld      |
| l    | 在e,f,g前，指定输出精度为double型                      | %lf      |
> 注：上表中m和n均为正整数

## 4. 指针

- C语言中，对于基类型相同的两个指针变量之间可以进行大小比较、赋值及减法运算，但加法运算没有意义。

### 1. 结构体指针

- ->只用于结构体指针访问成员；
  .点只用于结构体名访问成员；

### 2. 函数指针

1. **定义**：如果在程序中定义了一个函数，那么在编译时系统就会为这个函数代码分配一段存储空间，这段存储空间的首地址称为这个函数的地址。而且函数名表示的就是这个地址。既然是地址我们就可以定义一个指针变量来存放，这个指针变量就叫作函数指针变量，简称函数指针。

2. 函数指针的定义方式为：
函数返回值类型 (* 指针变量名) (函数参数列表);
例如：` int(*p)(int, int); `

3. 如何用函数指针调用函数

```C++
  int Func(int x);   /*声明一个函数*/
  int (*p) (int x);  /*定义一个函数指针*/
  p = Func;          /*将Func函数的首地址赋给指针变量p*/
  ...
  int a = (*p) (1);
  ...
```

### 3. 指针初始化

### 4. 指针字节数

1. 指针字节数与定义类型无关，只与操作系统的位数有关，32位系统是4字节，64位系统是8字节。
2. 定义指针变量时基类型是代表该指针变量所指向的变量所占的字节数。
3. 变量的地址都是用该变量首字节的地址来表示的，例如ch变量的首地址是1000H则`char * p = &ch`则是通过基地址说明该地址的内容是属于ch变量的内容（因为char只占一个字节）。即1000H是ch变量的地址，这个地址里面存放的是ch变量的内容。p+1指向的地址为1001H，跟基类有关。

## 5. 函数

- C语言源程序的基本结构单位是函数。
- C语言允许函数类型缺省定义，此时函数值隐含的类型是int。
- 若已包含标准库头文件及相关命名空间，则系统不允许用户重新定义标准库函数。
- 因为程序在运行时才会给程序中定义的变量开辟内存空间和进行初始化，函数是在被调用的时候才会给形参和函数体内定义的变量开辟内存空间。带有默认形参的函数在给形参开辟空间后就会先把默认值赋给形参，若没有实参传递，形参值就是默认值，默认值必须是系统能确切找得到的值才能进行对带有默认值形参进行初始化，而局部变量不是在正在被调用的函数内定义的（形参是函数一开始就定义的）或者在其他函数内定义并被使用完就被释放掉了，因此系统就会找不到一个确切的值赋给形参，所以函数参数默认值不允许为局部变量。 默认值不可以是局部变量，因为默认参数的函数调用是在编译时确定的，而局部变量的位置与值在编译时均无法确定。

### 1. 常成员函数

声明：<类型标志符>函数名（参数表）const；
说明：

1. const是函数类型的一部分，在实现部分也要带该关键字。
2. const关键字可以用于对重载函数的区分。
3. 常成员函数不能更新类的成员变量，也不能调用该类中没有用const修饰的成员函数，只能调用常成员函数。
4. const是函数类型的一部分，在实现部分也要带该关键字。

#### 1. scanf

- scanf 函数中的格式控制字符串是为了输入数据用的，无论其中有什么字符，也不会输出到屏幕上；
- scanf() 的格式控制串可以使用其他非空白字符，如逗号，但在输入时必须输入这些字符，以保证匹配就可以。

> **scanf, gets, getchar**
>
> - gets是得到一整行的字符串, 可以接收空格;
> - getchar是得到一个字符；
> - scanf("%s")是得到一个连续的字符串，遇到空格、回车、Tab键会自动终止；

#### 2. printf

格式：

```C
int printf ( const char * format, ... );
```

返回值：正确返回输出的字符总数，错误返回负值，与此同时，输入输出流错误标志将被置值，可由指示器ferror来检查输入输出流的错误标志。

### 2. 内存分配函数

#### 1. malloc

函数原型：

```C
 void *malloc(unsigned int num_bytes); 
```

**说明：**
该函数只有1个参数，就是要分配内存的总字节数。分配完毕后，不会自动初始化。

#### 2. calloc

函数原型：

```C
void *calloc(unsigned n, unsigned size)l;
```

**说明：**
该函数有2个参数，第1个参数是需要分配多少个这种数据类型的数据，第二个参数是需要分配的数据类型所占的字节数。分配完成后，被分配的数据被自动初始化成该数据类型的缺省值，数值型为0，字符型为'\0'。
>
> - malloc和calloc函数在头文件stdib.h中，使用时需要用预处理指令将这个头文件包括进来
> - 用malloc()和calloc()函数完成内存分配后，这两个函数都会返回一个void *类型的指针，这个指针所指的位置就是刚刚分配的内存的首地址。

#### 3. free

函数原型：

```C
void free(void *FirstBytes);
```

free()的参数就是由malloc()或calloc()所分配内存块的首地址。
当动态内存的变量不再使用的时候，就应该立刻调用free()函数，收回分配的内存，以供下次分配使用。

### 3. 字符串处理函数

#### 1. strlen

格式：strlen(str)
功能：由函数值返回字符串str的实际长度，即不包括'\0'在内的实际字符的个数
说明：函数括号后的参数可以是字符数组名，也可以是字符串常量

#### 2. strcat

格式：strcat(str1,str2)
功能：把字符数组str2中的字符串连接到字符数组str2的末尾，将连接后的结果放在字符数组 strl 中，字符串str2不变，函数值返回字符数组 strl 的首地址。
说明：

1. 函数有两个参数，str1只能是字符数组名，str2可以是字符数组名，也可以是字符串常量。
2. 字符数组str1应定义得足够大，以便能容纳连接后的两个字符串。
3. 连接后字符数组str1中原有的'\0'被字符串str2的第一个字符替代，且str1中保留了str2中的'\0'，作为连接后 strl 的字符串结束标志。

#### 3. strcpy

格式：strepy(str1,str2)
功能：把字符数组str2中的字符串复制到字符数组str1中，复制后的结果放在strl中,str2不变，函数值返回字符数组str1的首地址.
说明：

1. 函数应有两个参数，str1只能是字符数组名，str2可以是字符数组名，也可以是字符串常量。
2. 字符数组str1的长度要大于或等于字符数组str2的长度。
3. 复制时连同str2中的'\0'一起被复制到str1中。
4. 完成复制后的str1中原有字符被str2覆盖。
5. 字符数组str1和字符数组str2之间的赋值只能用strcpy(str1,str2)，不能用strl=str2。
6. 字符数组str1和字符数组str2内容的交换可以借助字符数组t，用strcpy()函数实现，即strcpy(t, str1);strcpy(str1,str2);strcpy(str2,t)；三个语句实现字符串的交换。

#### 4. strcmp

格式：strcmp(str1,str2)
功能：比较字符数组str1中字符串与字符数组str2中字符串的大小，函数返回值分为三种情况：

1. 若 strl 等于str2，则函数返回值等于0;
2. 者 strl 大于str2，则函数返回值大于0;
3. 若 strl 小于str2，则函数返回值小于0。
不能直接用关系运算符（例如>、<）比较两个字符串的大小，必须使用函数strcmp。

说明：

1. 函数应有两个参数，这两个参数既可以是字符数组，也可以是字符。
2. 字符串的比较方法是对两个字符串从左至右按字符的 ASCII 码值大小逐个比较，直到出现不同的字符或遇到'\0'为止。

#### 5. strlwr、strupr

1. strlwr函数
  格式：strlwr(str)
  功能：将字符串中的所有大写英文字母转换成小写英文字母，所有的非大写英文字母不变。
2. strupr函数
  格式：strupr(str)
  功能：将字符串中的所有小写英文字母转换成大写英文字母，所有的非小写英文字母不变。

### 4. 预处理命令

当用户发出编译命令时，系统先作预处理后再进行编译。在源程序被编译之前必须由编译预处理程序将它们替换成 C 语言编译程序所能接受的正文。编译预处理是编译程序的一部分，是在编译前对源程序进行的一些预加工。编译预处理功能是 C 语言的特征之。预处理命令可以出现在程序的任何位置，其作用域是从出现点到所在源程序的末尾。

- 不能对宏进行取地址操作。而++，--操作是先从内存取值到寄存器然后寄存器加一后再写入内存中，必然涉及如地址操作。

#### 1. 宏定义

##### 1. 不带参数的宏定义

定义格式：`# define 宏名 字符串`
不带参数的宏定义即符号常量定义，而符号常量又叫宏名，使用时要注意以下几点：

1. 在程序中用""括起来的字符串中，即使有的字符串与宏名相同，也不进行替换。
2. 宏定义只是一种简单的字符替代，不进行语法检查，只有在编译已被宏展开后的源程序时才会发现措法错误并报错。例如：若将`＃ define SIZE 20`的零写成英文字母'o'，程序中的`x=SIZE+15`；会替换为`x=2o+15`；再对其进行编译时系统就会报错。
3. `# define`命令出现在函数的外部，宏名的有效范围为定义命令之后到本文件结束。可以用`# undef`命令终止宏定义的作用域。
4. 宏定义与变量定义不同，它只作字符替换，不分配内存空间。
5. 宏定义可以嵌套使用。

##### 2．带参数的宏定义

定义格式：`# define 宏名(形参表) 字符串`
注意：对于带参数的宏定义，宏展开不只是进行简单的字符串替换，还要进行参数替换。
**举例:**

```C
# include <stdio.h>
# define PI 3.14159
# define S(r) PI*r*r
int main()
{
  float a, area;
  a = 3.6;
  area = S(a);
  printf("%f\n",area);
  return 0;
}
```

对不带实参的宏，则按`# define`命令行中指定的字符串从左到右进行替换。若串中包含宏中的形参（如r），则将程序中相应的实参（可以是常量、变量或表达式）代替形参。如果宏定义中的字符串中的字符不是参数字符（如 PI\*r\*r 中的＊号），则保留。这样就形成了替换的字符串。
例子中赋值语句`area = S(a);`经宏替换展开后为：`area = 3.14159*a*a`。
若将赋值语句`area = S(a);`中参数a改为a+2，即`area = S(a+2);`，则宏替换为`area = 14159*a+2*a+2`；显然该宏替换结果与原意不符，程序运行结果出错。因此，应将宏定义修改为：`# define S(г) PI*(t)*(t)`，而修改后宏替换为：`area = 3.14159*(a+2)*(a+2);`对带参数的宏定义需注意：

1. 宏定义时宏名与括号之间没有空格，若有空格则会把空格后的所有字符都看成宏体。
2. 带参数的宏在替换时，不仅宏名被宏体替换，同时形参被实参替换。
3. 建议带运算符的宏体和形参用()括起来。

使用宏替换可以减少程序中重复书写某些字符串的工作量。
> 带参数的宏与有参函数的区别：
>
> 1. 函数调用时，先求出实参表达式的值，再代入形参；带参数的宏定义只是进行简单的字符替换。
> 2. 函数调用是在程序运行时处理，分配临时的内存单元；宏展开是在编译时进行的，在展开时不分配内存单元。
> 3. 对函数的形参和实参都要定义类型，且要求一致；宏不存在类型问题，宏名无类型，其参数也无类型。
> 4. 调用函数只可得到一个返回值；使用宏可以设法得到几个结果。
> 5. 函数调用不会使源程序变长；宏展开会使源程序变长。
> 6. 函数调用占用运行时间；宏展开不占运行时间，只占编译时间。

#### 2.文件包含

定义：一个源文件可以将另外一个源文件的全部内容包含进来。C语言提供了`＃ include`命令用来实现“文件包含”的操作。
文件包含有如下两种格式：

1. 格式一：`# inelude` "文件标识"
   文件标识可以包含文件路径（即文件在哪个目录下），使用时系统先在引用被包含文件的源文件所在的目录下寻找被包含文件。如果找不到，系统再按指定的标准方式检索其他目录，直到找到为止。此格式通常用于用户自己编写的文件。
2. 格式二：`# include` <文件名>
   系统只按规定的标准方式检索文件目录，通當使用系统提供的标准头文件时用<>。
**说明：**
   1. 文件包含的作用就是在编译预处理时将被包含文件的全部内容复制并插人`# include`命令处。
   2. 一个include命令只能指定一个被包含文件。如果有n个被包含文件，则需要用n个include命令，且一个命令占一行。
   3. 使用文件包含时，在被包含文件中绝对不能main()函数。
   4. 文件包含可以嵌套使用。
   5. 被包含文件中的全局变量在其所在的文件中有效。

#### 3. 条件编译

定义：对部分内容指定编译的条件，使其只在满足一定条件才进行编译。条件编译当然也可以用条件语句来实现，但生成的目标代码程序很长。采用条件编译，根据条件只编译其中的程序段1或程序段么，生成的目标程序较短。
常见的条件编译命令有如下三种形式：

1. 形式1

  ```C
   # ifdef 标识符
        程序段1
   # else
        程序段2
   # endif 
  ```

   其中，标识符一般是用`# define`定义的宏名，也可缺省`# else`部分。
   功能：若标识符定义过，则对程序段1进行编译，否则对程序段2进行编译。
2. 形式2

   ```C
   # ifndef 标识符
        程序段1
   # else 
        程序段2
   # endif
   ```

  功能：若标识符未定义过，则对程序段1进行编译，否则对程序段2进行编译。
  3. 形式3

  ```C
   #if 表达式
        程序段1
   # else
        程序段2
   # endif
   ```

   功能：当表达式的值非0时，则对程序段1进行编译，否则对程序段2进行编译。
   条件编译指令都是以#开头，其章义与洗择结构语句`if-else`完全不同。`if-else`语句分支中的程序段都会被生成到目标代码中，由程序在执行过程中根据条件来决定执行哪一个分支的代码，但条件编译`#if-#else-#endif`则是在编译预处理时起作用，满足条件的程序段会被生成到目标代码中，而另一部分则会被舍弃。

### 4. 文件操作函数

### 5. 形参和实参

1. 形参变量只有在被调用时才分配内存单元，在调用结束时，即刻释放所分配的内存单元。因此，形参只在函数内部有效。函数调用结束返回主调用函数后则不能再使用该形参变量。
2. 实参可以是常量、变量、表达式、函数等，无论实参是何种类型的量，在进行函数调用时，它们都必须有确定的值，以便把这些值传送给形参。因此应预先用赋值，输入等办法使参数获得确定值。
3. 实参和形参在数量上，类型上、顺序上应严格一致，否则就会发生类型不匹配的错误。
4. 在一般传值调用的机制中只能把实参传送给形参，而不能把形参的值反向地传送给实参。因此在函数调用过程中，形参值发生改变，而实参中的值不会变化。而在引用调用的机制当中是将实参引用的地址传递给了形参，所以任何发生在形参上的改变实际上也发生在实参变量上。

### 6. 值传递，地址传递，引用传递

1. 值传递

```C
find（int x）{}
y= find(z)；
```

上面的例子中，z是实参，x是形参。x变z不变。
实参是变量，表达式等值。在值传递过程中，实参和形参位于内存中两个不同地址中，实参先自己复制一次拷贝，再把拷贝复制给形参。所以，在值传递过程中，形参的变化不会对实参有任何的影响。
2. 地址传递（也称引用传递）
实参是指针。在函数调用的时候，实参传递给你的是指针地址，地址一样也就意味着实参和形参是一样的，当你的形参发生改变时，实参也会发生改变。

```C
find（int  &x）{}
y= find(z)；
```

上面的例子中，z是实参，x是形参。z随x而改变。

3、const引用传递

```C
find（const int  &x）{}
y= find(z)；
```

上面的例子中，z是实参，x是形参。z不随x而改变。
在值传递中要进行两次拷贝，浪费内存资源是相当可耻的，const的出现有效避免了这种情况的出现，只需拷贝一次就够了。

## 6. 数组

### 1. 与二维数组相关的地址表示形式

| 表示形式                           | 含义                  | 地址值      |
|------------------------------------|-----------------------|-------------|
| &a                                 | 指向二维数组的指针    | 2000        |
| a                                  | 二维数组名，第0行地址 | 2000        |
| a[0],\*(a+0),\*a                   | 第0行第0列地址        | 2000        |
| a+1,&a[1]                          | 第1行首地址           | 2008        |
| a[1],\*(a+1)                       | 第1行第0列元素地址    | 2008        |
| a[1]+1,\*(a+1)+1,&a\[1]\[1]        | 第1行第1列元素地址    | 2012        |
| \*(a[1]+1),\*(\*(a+1)+1),a\[1]\[1] | 第1行第1列元素的值    | 元素值为... |

> &a代表整个数组的地址，&a+1就是数组最后一个元素之后的下一个地址。

## 7. 文件

## 8. 结构体
